== Basic API

Persistit(TM) is a small, lightweight Java(TM) library that provides simple, fast and reliable data persistence for Java applications. It is designed to be embedded in Java application programs and to operate free of administration by the end-user.

Persistit stores data as key-value pairs in highly optimized B-Tree footnote:[Technically, Persistit implements B+-trees in which each page includes the page identifier of its right sibling page within the structure]  structures. Much like a Java Map implementation, Persistit associates at most one value with each unique instance of a key.

Persistit provides interfaces to access and modify keys and their associated values. Application code calls Persistit API methods to store, fetch, traverse and remove keys and records to and from the database. Persistit permits efficient multi-threaded concurrent access to database volumes. It is designed to minimize contention for critical resources and to maximize throughput on multi-processor machines.

== The Persistit Instance

To access Persistit, the application first constructs an instance of the link:apidocs/com/persistit/Persistit.html[+com.persistit.Persistit+] class and initializes it. This instance is the keystone of all subsequent operations.  It holds references to the buffers, maps and other structures needed to access B-trees. The life cycle of a Persistit instance should be managed as follows:

[source,java]
----
final Persistit db = new Persistit();
//
// register any TransactionalCache, Coder 
// and Renderer instances before initialization
//
db.initialize(configuration_properties);
try {
    // do application work
} finally {
    db.close();
}
----

The _configuration properties_ describe the memory allocation, initial set of volumes, the journal, and other settings needed to get Persistit started. See link:Configuration.html[Configuration] for details.

The +close+ method gracefully flushes all modified data to disk, stops background threads and unregisters JMX MBeans. 
****
The Persistit background threads are not daemon threads, so if your application returns from its static main method without calling +close+, the JVM will not automically exit.
****

Although it is recommended that normal shutdown should invoke +close+, Persistit is designed to recover a consistent database state in the event of an abrupt shutdown. See <<Recovery>>.

Within Persistit, key values are _segmented_ and _ordered_. Segmented means that you can append multiple primitive values or Strings to construct a concatenated key. Ordered means that the methods that enumerate key values within a Persistit database do so in a specified natural order. (See <<Keys>>).

A Persistit value may be any primitive value, any Serializable Java object, or an object of any class supported by a custom serialization helper class. When stored in the B-Tree, keys and values are represented by sequences of bytes. The byte sequence that represents a value may be of arbitrary length, bounded only by available heap memory. See <<Values>>.

[[Keys]]
== Keys

A key, represented by an instance of +com.persistit.Key+, is the identifier for a key/value pair within a tree. Internally a Key represents an array of bytes that constitutes the physical identity of the key/value pair within a tree. Logically, a key consists of a sequence of zero or more Java values, each of which is called a segment. Currently the following value types are implicitly supported in keys:

.Types Supported in +com.persistit.Key+
----
null
boolean and Boolean
byte (and Byte)
short (and Short)
char (and Character)
int (and Integer)
long (and Long)
float (and Float)
double (and Double)
java.lang.String
java.math.BigInteger
java.math.BigDecimal
java.util.Date
byte[]
----

In addition, you may register custom implementations of the com.persistit.encoding.KeyCoder interface to support encoding of other object classes. By default, String values are encoded in UTF-8 format. An application can register an implementation of the com.persistit.encoding.KeyStringCoder interface to perform custom encoding of Strings.

=== Appending and Decoding Key Segments

The com.persistit.Key class provides methods to append and decode each of these types to and from a key segment. For each type listed above, there is an append method and a decode method. For example, for the long type, there are methods

[source,java]
----
public void append(long v)
public long decodeLong()
----

The Key class also provides methods to append and decode Object values to and from a key. Strings, Dates, objects of the corresponding wrapper classes for the primitive types listed above, and objects supported by registered KeyCoders are permitted. Primitive values are automatically boxed and unboxed as needed. The following code fragment demonstrates key manipulation with automatic conversion of primitive types and their wrappers.

[source,java]
----
key.clear();              	// clear any previous key segments
key.append(new Integer(1234));
key.append("Atlantic");
key.append(1.23d);
key.reset();              	// reset index to beginning for decoding
int v = key.decodeInt();  	// v will be 1234
StringBuffer sb = new StringBuffer();
key.decodeString(sb);     	// sb will contain "Atlantic"
Double d = (Double)decode();    // decode will return a Double
----

In this code segment, an object of type Integer is appended to the key’s value sequence, and then the same value is later decoded as a primitive int value. A String is appended and then decoded into a StringBuffer. Finally, a primitive double value is appended and then decoded as an object of class Double.

As a convenience, each of the append methods has a corresponding method called to that replaces the final segment of the key with the supplied value rather than appending an additional segment. For example:

[source,java]
----
key.clear();         	// clear any previous key segments
key.append("Atlantic");  // append segment "Atlantic"
key.to("Pacific");   	// replace "Atlantic" with "Pacific"
key.reset();         	// reset index to beginning
String s = key.decode(); // s contains "Pacific"
----

For further information, see +com.persistit.Key+.


[[Values]]
== Values

A +com.persistit.Value+ object holds a value. Unlike keys, Value objects have no restriction on the types of data they can represent. In particular, a Value may contain null, any of the primitive types, or any object. Value provides optimized representations for the following types:

.Types Implicitly Supported by +com.persistit.Value+
----
null
all primitive types
all arrays
java.math.BigInteger
java.math.BigDecimal
java.lang.String
java.util.Date
----

A value of any other type is serialized into and and deserialized from a Value by a helper class that implements com.persistit.encoding.ValueCoder. You may register custom ValueCoders to provide specialized or optimized encoding for any class not listed above. When there is no explicitly registered ValueCoder, Persistit creates an appropriate default ValueCoder that uses either reflection or standard Java serialization to transfer information between the object and the Value's backing byte array. See <<Serialization>> for additional information.

A Value may also be in the undefined state, which results from performing a fetch operation on a key for which no value is present in the database. The undefined state is distinct from the value +null+ and can be queried with the +isDefined()+ method.

For further information, see +com.persistit.Value+.

== Access Methods

The primary low-level interface for interacting with Persistit is +com.persistit.Exchange+. The Exchange class provides all methods for storing, deleting, fetching and traversing key/value pairs. These methods are summarized here and described in detail in the API documentation.

Although the underlying Persistit database is designed for highly concurrent multi-threaded operation, the Exchange object itself is not thread-safe. Each thread should create and use its own Exchange object(s) when accessing the database.

To create an Exchange you provide a Volume name (or alias) and a tree name in its constructor. The constructor will optionally create a new tree in that Volume if a tree having the specified name is not found. An application may construct an arbitrary number of Exchange objects. Creating a new Exchange has no effect on the database if the specified tree already exists. Tree creation is thread-safe: multiple threads concurrently constructing Exchanges using the same Tree name will safely result in the creation of only one new tree.

An Exchange is a moderately complex object that requires several thousand bytes of heap space. Memory-constrained applications should construct Exchanges in moderate numbers. An Exchange internally maintains some optimization information such that references to nearby Keys within a tree are accelerated. Performance may benefit from using a different Exchange for each area of the Tree being accessed.

Persistit offers Exchange pooling to avoid rapidly creating and destroying Exchange objects in multi-threaded applications.  In particular, web applications may benefit from using the Exchange pool.

An Exchange is always associated with a com.persistit.Key and a com.persistit.Value. Typically you work with an Exchange in one of the following patterns:
. Modify the Key, perform a +fetch+ operation, and extract the Value.
. Modify the Key, modify the Value, and then perform a +store+ operation.
. Modify the Key, and then perform a +remove+ operation.
. Optionally modify the Key, perform a +traverse+ operation, then read the resulting Key and/or Value.

These four methods, plus a few other methods listed here, are the primary low-level interface to the database. Semantics are as follows:

[horizontal]
+fetch+:: Reads the stored value associated with this Exchange's Key and modifies the Exchange’s Value to reflect that value.
+store+:: Inserts or replaces the key/value pair for the specified key in the Tree either by replacing the former value, if there was one, or inserting a new value.
+fetchAndStore+:: Fetches and then replaces the stored value. Upon completion, Value reflects the formerly stored value for the current Key. This operation is atomic, as opposed to sequential calls to fetch and store.
+remove+, +removeAll+, +removeKeyRange+:: Removes key/value pairs from the Tree. Versions of this method specify either a single key or a range of keys to be removed.
+fetchAndRemove+:: Fetches and then removes the stored value. Upon completion, Value reflects the formerly stored value for the current Key. This operation is atomic, as opposed to sequential calls to fetch and remove.
+traverse+, +next+, +previous+:: Modifies the Exchange’s Key and Value to reflect a successor or predecessor key within the tree. See +com.persistit.Key+ for detailed information on the order of traversal.
+incrementValue+:: Atomically increments or decrements a long (64-bit integer) value associated with the current Key, and returns the modified value. If there is currently no value associated with the key then incrementValue creates one and assigns an initial value to it. This operation provides a convenient way for concurrent threads to safely allocate unique long integers without an explicit transaction scope.
+hasNext+, +hasPrevious+:: Indicates, without modifying the Exchange’s Value or Key objects, whether there is a successor or predecessor key in the Tree.
+getChangeCount+:: Number of times the Tree for this Exchange has changed. This count may be used as a reliable indicator of whether the Tree has changed since some earlier instant in time. For example, it is used to detect concurrent modifications by PersistitMap.

Because Persistit permits concurrent operations by multiple threads, there is no guarantee that the underlying database will remain unchanged after any of these operations is completed. However, each of these methods operates atomically. That is, the inputs and outputs of each method are consistent with some valid state of the underlying Persistit backing store at some instant in time. The Value and Key objects for the Exchange represent that consistent state even if some other thread subsequently modifies the underlying database.

For convenience, Exchange delegates +append+ and +to+ methods to +com.persistit.Key+. For example, Exchange provides the following methods that delegate to the identically named methods of Key :

[source,java]
----
public Exchange append(long v)
public Exchange append(String v)
----
To allow code chaining these methods of Exchange return the same Exchange. For example, it is valid to write code such as

[source,java]
----
exchange.clear().append(" Pacific").append("Ocean").append(123).fetch();
----

This example fetches the value associated with the concatenated key
+{“Pacific”, ”Ocean”, 123}+.

Exchange also delegates other key manipulation methods. (See +com.persistit.Exchange+.)

=== Large Values

Persistit stores arbitrarily large values. For example, it is possible to store an image as a single value in the database. The size of the value to be stored is constrained by available heap memory; the entire value must be able to be serialized into an in-memory byte array in order for Persistit to store or retrieve it. Large values are broken up across multiple data pages and are not necessarily stored in contiguous file areas.

On occasion it may be desirable to fetch only part of a large value. For example, a developer may wish only to extract summary information from the beginning of a the backing byte array for an Image. Special versions of the fetch and traverse accept a minimum byte count; these methods guarantee that at least the byte positions of the resulting Value object up to that count are valid. Using this technique can prevent Persistit from reading large numbers of pages from the disk in order to examine only a small portion of the record.

[[PersistitMap]]
=== PersistitMap


In addition to low-level access methods on keys and values, Persistit provides com.persistit.PersistitMap, which implements the java.util.SortedMap interface. PersistitMap uses the Persistit database as a backing store so that key/value pairs are persistent, potentially shared with all threads, and limited in number only by disk storage.

Keys for PersistitMap must conform to the constraints described above under Keys. Values must conform to the constraints described for Values.

The constructor for PersistitMap takes an Exchange as its sole parameter. All key/value pairs of the Map are stored within the tree identified by this Exchange. The Key supplied by the Exchange becomes the root of a logical tree. For example:

[source,java]
----
Exchange ex = new Exchange("myVolume", "myTree", true);
ex.append("USA").append("MA");
PersistitMap<String, String> map = new PersistitMap<String, String>(ex);
map.put("Boston", "Hub");
----

places a key/value pair into the myTree with the concatenated key +{"USA ","MA","Boston"}+ and a value of +"Hub"+.

Because Persistit is designed for concurrent operation it is possible (and often intended) for the backing store of PersistitMap to be changed by other threads while a java.util.Iterator is in use. Generally the expected behavior for an Iterator on a Map collection view is to throw a ConcurrentModificationException if the underlying collection changes. This is known as fail-fast behavior. PersistitMap implements this behavior by throwing a ConcurrentModificationException in the event the Tree containing the map changes. An application can detect that the map may have changed due to a programming error in case the design contract calls for it to remain unchanged by catching this exception.

However, sometimes it may be desirable to use PersistitMap and its collections view interfaces to iterate across changing data. Internally, Persistit uses the traverse method to retrieve the next highest key in the key sort order in order to implement the Iterator’s hasNext and next methods. The result will depend on the content of the database at the instant these operations are performed. PersistitMap provides the method setAllowConcurrentModification to enable this behavior. By default, concurrent modifications are not allowed.

=== Exceptions in PersistitMap

Persistit operations throw a variety of exceptions that are subclasses of com.persistit.exception.PersistitException. However, the methods of the SortedMap interface do not permit arbitrary checked exceptions to be thrown. Therfore, PersistitMap wraps any PersistitException generated by the underlying database within a com.persistit.PersistitMap.PersistitMapException. This exception is unchecked and can therefore be thrown by methods of the Map interface. Applications using PersistitMap should catch and handle PersistitMap.PersistitMapException. The original PersistitException is available through the getCause method.

[[KeyFilter]]
== KeyFilter

A +com.persistit.KeyFilter+ defines a subset of all possible key values. You can supply a KeyFilter to the +traverse+ method of an Exchange. You can also specify a KeyFilter for any Iterator returned by the collection views of a PersistitMap. In either case, the key/value pairs covered by traversing the database or iterating over the collection view are restricted to those selected by the KeyFilter.

Use of a KeyFilter is illustrated by the following code fragment:

[source,java]
----
Exchange ex = new Exchange("myVolume", "myTree", true);
KeyFilter kf = new KeyFilter("{\"Bellini\":\"Busoni\"}");
ex.append(Key.BEFORE);
while (ex.next(kf))
{
 System.out.println(ex.getKey().reset().decodeString());
}
----

This simple example emits the string-valued keys within myTree whose values fall alphabetically between “Bellini” and “Busoni”, inclusive.
