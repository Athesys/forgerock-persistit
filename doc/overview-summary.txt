
Persistit 2.2
=============

----
This document generates HTML added to the com.persistit JavaDoc package. It can also stand alone in the doc set if desired.  The intent is to touch on much of the functionality in Persistit without too much detail; links in the text to API documentation should be completed (preferably by a script) so that any reference to a com.persistit.XXX object has a link to the API doc set.  Method names should also be linked when possible.

(Remove this block before publication.)
----

Persistit(TM) is a small, lightweight Java(TM) library that provides simple, fast and reliable data persistence for Java applications. It is designed to be embedded in Java application programs and to operate free of administration by the end-user.

This document provides a brief overview.

== API Overview

Persistit stores data as key-value pairs in highly optimized B-Tree structures. Much like a Java Map implementation, Persistit associates at most one value with each unique instance of a key.

Persistit provides interfaces to access and modify keys and their associated values. The developer writes code to construct key and value instances and to store, fetch, traverse and remove keys and records to and from the database. Persistit permits efficient multi-threaded concurrent access to database volumes. It is designed to minimize contention for critical resources and to maximize throughput on multi-processor machines.

In addition to low-level access methods on keys and values, Persistit provides com.persistit.PersistitMap, which implements the java.util.SortedMap interface. PersistitMap uses the Persistit database as a backing store so that key/value pairs are persistent, potentially shared with all threads, and limited in number only by disk storage. (See PersistitMap.)

Within Persistit, key values are _segmented_ and _ordered_. Segmented means that you can append multiple primitive values or Strings to construct a concatenated key. Ordered means that the methods that enumerate key values within a Persistit database do so in a specified natural order. (See Keys).

A Persistit value may be any primitive value, any Serializable Java object, or an object of any class supported by a custom serialization helper class. When stored in the B-Tree, keys and values are represented by sequences of bytes. The byte sequence that represents a value may be of arbitrary length, bounded only by available heap memory. (See Values.)

[[KEYS]]
=== Keys

A key, represented by an instance of +com.persistit.Key+, is the identifier for a key/value pair within a tree. Internally a Key represents an array of bytes that constitutes the physical identity of the key/value pair within a tree. Logically, a key consists of a sequence of zero or more Java values, each of which is called a segment. Currently the following value types are implicitly supported in keys:

.Types Supported in +com.persistit.Key+
----
null
boolean and Boolean
byte (and Byte)
short (and Short)
char (and Character)
int (and Integer)
long (and Long)
float (and Float)
double (and Double)
java.lang.String
java.math.BigInteger
java.math.BigDecimal
java.util.Date
byte[]
----

In addition, you may register custom implementations of the com.persistit.encoding.KeyCoder interface to support encoding of other object classes. By default, String values are encoded in UTF-8 format. An application can register an implementation of the com.persistit.encoding.KeyStringCoder interface to perform custom encoding of Strings.

=== Appending and Decoding Key Segments

The com.persistit.Key class provides methods to append and decode each of these types to and from a key segment. For each type listed above, there is an append method and a decode method. For example, for the long type, there are methods

[source,java]
----
public void append(long v)
public long decodeLong()
----

The Key class also provides methods to append and decode Object values to and from a key. Strings, Dates, objects of the corresponding wrapper classes for the primitive types listed above, and objects supported by registered KeyCoders are permitted. Primitive values are automatically boxed and unboxed as needed. The following code fragment demonstrates key manipulation with automatic conversion of primitive types and their wrappers.

[source,java]
----
key.clear();                  // clear any previous key segments
key.append(new Integer(1234));
key.append("Atlantic");
key.append(1.23d);
key.reset();                  // reset index to beginning for decoding
int v = key.decodeInt();      // v will be 1234
StringBuffer sb = new StringBuffer();
key.decodeString(sb);         // sb will contain "Atlantic"
Double d = (Double)decode();  // decode will return a Double
----

In this code segment, an object of type Integer is appended to the key’s value sequence, and then the same value is later decoded as a primitive int value. A String is appended and then decoded into a StringBuffer. Finally, a primitive double value is appended and then decoded as an object of class Double. (See the com.persistit.Key API documentation for details on these operations.)

As a convenience, each of the append methods has a corresponding method called to that replaces the final segment of the key with the supplied value rather than appending an additional segment. For example:

[source,java]
----
key.clear();             // clear any previous key segments
key.append("Atlantic");  // append segment "Atlantic"
key.to("Pacific");       // replace "Atlantic" with "Pacific"
key.reset();             // reset index to beginning
String s = key.decode(); // s contains "Pacific"
----

For further information, see the API documentation for com.persistit.Key.

[[VALUES]]
=== Values

A +com.persistit.Value+ object holds a value. Unlike keys, Value objects have no restriction on the types of data they can represent. In particular, a Value may contain null, any of the primitive types, or any object. Value provides optimized representations for the following types:

.Types Implicitly Supported by +com.persistit.Value+
----
null
all primitive types
all arrays
java.math.BigInteger
java.math.BigDecimal
java.lang.String
java.util.Date
----

A value of any other type is serialized into and and deserialized from a Value by a helper class that implements com.persistit.encoding.ValueCoder. You may register custom ValueCoders to provide specialized or optimized encoding for any class not listed above. When there is no explicitly registered ValueCoder, Persistit creates an appropriate default ValueCoder that uses either reflection or standard Java serialization to transfer information between the object and the Value's backing byte array. See Persistit 2.1 Object Serialization for additional information.

A Value may also be in the undefined state, which results from performing a fetch operation on a key for which no value is present in the database. The undefined state is distinct from the value +null+ and can be queried with the +isDefined()+ method.

For further information, see the API documentation for +com.persistit.Value+.

=== Access Methods

The primary low-level interface for interacting with Persistit is +com.persistit.Exchange+. The Exchange class provides all methods for storing, deleting, fetching and traversing key/value pairs. These methods are summarized here and described in detail in the API documentation.

Although the underlying Persistit database is designed for highly concurrent multi-threaded operation, the Exchange object itself is not thread-safe. Each thread should create and use its own Exchange object(s) when accessing the database.

To create an Exchange you provide a Volume name (or alias) and a tree name in its constructor. The constructor will optionally create a new tree in that Volume if a tree having the specified name is not found. An application may construct an arbitrary number of Exchange objects. Creating a new Exchange has no effect on the database if the specified tree already exists. Tree creation is thread-safe: multiple threads concurrently constructing Exchanges using the same Tree name will safely result in the creation of only one new tree.

An Exchange is a moderately complex object that requires several thousand bytes of heap space. Memory-constrained applications should construct Exchanges in moderate numbers. An Exchange internally maintains some optimization information such that references to nearby Keys within a tree are accelerated. Performance may benefit from using a different Exchange for each area of the Tree being accessed.

Persistit offers Exchange pooling to avoid rapidly creating and destroying Exchange objects in multi-threaded applications.  In particular, web applications may benefit from using the Exchange pool.

An Exchange is always associated with a com.persistit.Key and a com.persistit.Value. Typically you work with an Exchange in one of the following patterns:
. Modify the Key, perform a +fetch+ operation, and extract the Value.
. Modify the Key, modify the Value, and then perform a +store+ operation.
. Modify the Key, and then perform a +remove+ operation.
. Optionally modify the Key, perform a +traverse+ operation, then read the resulting Key and/or Value.

These four methods, plus a few other methods listed here, are the primary low-level interface to the database. Semantics are as follows:

[horizontal]
+fetch+:: Reads the stored value associated with this Exchange's Key and modifies the Exchange’s Value to reflect that value.
+store+:: Inserts or replaces the key/value pair for the specified key in the Tree either by replacing the former value, if there was one, or inserting a new value.
+fetchAndStore+:: Fetches and then replaces the stored value. Upon completion, Value reflects the formerly stored value for the current Key. This operation is atomic, as opposed to sequential calls to fetch and store.
+remove+, +removeAll+, +removeKeyRange+:: Removes key/value pairs from the Tree. Versions of this method specify either a single key or a range of keys to be removed.
+fetchAndRemove+:: Fetches and then removes the stored value. Upon completion, Value reflects the formerly stored value for the current Key. This operation is atomic, as opposed to sequential calls to fetch and remove.
+traverse+, +next+, +previous+:: Modifies the Exchange’s Key and Value to reflect a successor or predecessor key within the tree. (See API documentation for com.persistit.Key for information on the order of traversal.)
+incrementValue+:: Atomically increments or decrements a long (64-bit integer) value associated with the current Key, and returns the modified value. If there is currently no value associated with the key then incrementValue creates one and assigns an initial value to it. This operation provides a convenient way for concurrent threads to safely allocate unique long integers without an explicit transaction scope.
+hasNext+, +hasPrevious+:: Indicates, without modifying the Exchange’s Value or Key objects, whether there is a successor or predecessor key in the Tree.
+getChangeCount+:: Number of times the Tree for this Exchange has changed. This count may be used as a reliable indicator of whether the Tree has changed since some earlier instant in time. For example, it is used to detect concurrent modifications by PersistitMap.

Because Persistit permits concurrent operations by multiple threads, there is no guarantee that the underlying database will remain unchanged after any of these operations is completed. However, each of these methods operates atomically. That is, the inputs and outputs of each method are consistent with some valid state of the underlying Persistit backing store at some instant in time. The Value and Key objects for the Exchange represent that consistent state even if some other thread subsequently modifies the underlying database.

For convenience, Exchange delegates +append+ and +to+ methods to +com.persistit.Key+. For example, Exchange provides the following methods that delegate to the identically named methods of Key :

[source,java]
----
public Exchange append(long v)
public Exchange append(String v)
----
To allow code chaining these methods of Exchange return the same Exchange. For example, it is valid to write code such as

[source,java]
----
exchange.clear().append(" Pacific").append("Ocean").append(123).fetch();
----

This example fetches the value associated with the concatenated key
+{“Pacific”, ”Ocean”, 123}+.

Exchange also delegates other key manipulation methods. See the com.persistit.Exchange API documentation for details.

==== Large Values

Persistit stores arbitrarily large values. For example, it is possible to store an image as a single value in the database. The size of the value to be stored is constrained by available heap memory; the entire value must be able to be serialized into an in-memory byte array in order for Persistit to store or retrieve it. Large values are broken up across multiple data pages and are not necessarily stored in contiguous file areas.

On occasion it may be desirable to fetch only part of a large value. For example, a developer may wish only to extract summary information from the beginning of a the backing byte array for an Image. Special versions of the fetch and traverse accept a minimum byte count; these methods guarantee that at least the byte positions of the resulting Value object up to that count are valid. Using this technique can prevent Persistit from reading large numbers of pages from the disk in order to examine only a small portion of the record.

[[PERSISTIT_MAP]]
=== PersistitMap

Persistit provides an implementation of the java.util.SortedMap interface called com.persistit.PersistitMap. PersistitMap uses Persistit as its backing store, permitting large maps to be stored efficiently on disk using constant heap memory space.

Keys for PersistitMap must conform to the constraints described above under Keys. Values must conform to the constraints described for Values.

The constructor for PersistitMap takes an Exchange as its sole parameter. All key/value pairs of the Map are stored within the tree identified by this Exchange. The Key supplied by the Exchange becomes the root of a logical tree. For example:

[source,java]
----
Exchange ex = new Exchange("myVolume", "myTree", true);
ex.append("USA").append("MA");
PersistitMap<String, String> map = new PersistitMap<String, String>(ex);
map.put("Boston", "Hub");
----

places a key/value pair into the myTree with the concatenated key +{"USA ","MA","Boston"}+ and a value of +"Hub"+.

Because Persistit is designed for concurrent operation it is possible (and often intended) for the backing store of PersistitMap to be changed by other threads while a java.util.Iterator is in use. Generally the expected behavior for an Iterator on a Map collection view is to throw a ConcurrentModificationException if the underlying collection changes. This is known as fail-fast behavior. PersistitMap implements this behavior by throwing a ConcurrentModificationException in the event the Tree containing the map changes. An application can detect that the map may have changed due to a programming error in case the design contract calls for it to remain unchanged by catching this exception.

However, sometimes it may be desirable to use PersistitMap and its collections view interfaces to iterate across changing data. Internally, Persistit uses the traverse method to retrieve the next highest key in the key sort order in order to implement the Iterator’s hasNext and next methods. The result will depend on the content of the database at the instant these operations are performed. PersistitMap provides the method setAllowConcurrentModification to enable this behavior. By default, concurrent modifications are not allowed.

==== Exceptions in PersistitMap

Persistit operations throw a variety of exceptions that are subclasses of com.persistit.exception.PersistitException. However, the methods of the SortedMap interface do not permit arbitrary checked exceptions to be thrown. Therfore, PersistitMap wraps any PersistitException generated by the underlying database within a com.persistit.PersistitMap.PersistitMapException. This exception is unchecked and can therefore be thrown by methods of the Map interface. Applications using PersistitMap should catch and handle PersistitMap.PersistitMapException. The original PersistitException is available through the getCause method.

[[KEY_FILTER]]
=== KeyFilter

A +com.persistit.KeyFilter+ defines a subset of all possible key values. You can supply a KeyFilter to the traverse methods of an Exchange.  You can also specify a KeyFilter for any Iterator returned by the collection views of a PersistitMap.  In either case, the key/value pairs covered by traversing the database or iterating over the collection view are restricted to those selected by the KeyFilter.

Use of a KeyFilter is illustrated by the following code fragment:

[source,java]
----
Exchange ex = new Exchange("myVolume", "myTree", true);
KeyFilter kf = new KeyFilter("{\"Bellini\":\"Busoni\"}");
ex.append(Key.BEFORE);
while (ex.next(kf))
{
 System.out.println(ex.getKey().reset().decodeString());
}
----

This simple example emits the string-valued keys within myTree whose values fall alphabetically between “Bellini” and “Busoni”, inclusive.

== Physical B-Tree Representation

=== Pages

Persistit stores its data in one or more files called Volumes. Each volume may contain an arbitrary number of named B-Trees. Persistit manages volume files internally in sections called pages. Each page is the same size within a volume. The page size is configurable and may be 1K, 2K, 4K, 8K (the default size) or 16K bytes long. Once the page size for a volume has been established, it cannot be changed. To tell Persistit what volume file(s) to use and various other parameters that govern its allocation of memory resources, the developer provides either a java.util.Properties object or a file containing properties.
(See <<CONFIGURATION,Configuration>>.)

=== Volumes

Within a Volume there may be an arbitrary number B-Trees. (B-Trees are also known as balanced trees or simply Trees in this document.) In Persistit, a tree is a data structure comprising a root page and subordinate index and data pages. A data page contains a representation of an arbitrary number of key/value pairs. An index page contains a representation of an arbitrary number of keys, each associated with a subordinate index or data page having related information. Data pages are leaf pages because they have no children while index pages are non-leaf pages because they must have children.

The defining characteristic of a B-Tree is that it is height-balanced: the length of the path from the root page to any leaf page is the same. Persistit trees typically range from 1 to 5 levels in depth; the upper bound on tree depth is 20. Each Volume contains a special directory Tree used to identify all other Trees in the Volume. The directory Tree is implicitly used whenever Persistit creates, removes or enumerates the Trees in a volume.

=== The Journal

Persistit writes all updated pages to the _journal_. The journal is append-only; new records are written only at the end. The journal consists of a numbered series of files having a configurable maximum size. When a journal file becomes full Persistit closes it and begins a new file with the next counter value. In normal operation an independent Copier thread copies pages from the journal back into their home Volume files, allowing old files to be deleted.

The journal is critical to ensuring Persistit can recover structurally intact B-Trees and apply any committed transactions after a system failure. (For more details on the journal, checkpoints and transactions, see Integrity and Recovery.)

=== The Buffer Pool

Persistit maintains a cache of page copies in memory called the buffer pool. The buffer pool is a critical resource in reducing disk I/O and providing good runtime performance. Specifically, after performing a relatively expensive disk operation to read a copy of a page into the buffer pool, Persistit retains that copy to allow potentially many fetch and update operations to be performed against keys and values stored in that page.

Persistit optimizes update operations by writing updated database pages lazily, generally a few seconds to minutes after the update has been performed on the in-memory copy of the page cached in the buffer pool. By performing its writes lazily, Persistit allows many update operations to be completed on each page before invoking a relatively expensive disk operation to write the updated version of the page to the Volume.

A Buffer Pool is a collection of buffers allocated from the heap for the duration of Persistit’s operation. In Persistit 2.1 all buffers are allocated when the embedding application invokes one of the initialize methods of com.persistit.Persistit and are released when the application invokes close. There is one buffer pool for each buffer size specified in the configuration properties.

Persistit allocated buffers from but buffer pool on a least-recently-used (LRU)  basis. Most applications exhibit behavior in which data, having been accessed once, is read or updated several more times before the application moves to a different area of the database (locality of reference). LRU is an allocation strategy the yields reasonably good overall throughput by maintaining pages that are likely to be used again in the buffer pool in preference to pages that have not been used for a relatively long time.

Generally, allocating more buffers in the buffer pool increases the likelihood that a page will be found in the pool rather than having to be reloaded from disk. Since disk I/O is relatively expensive, this means that enlarging the buffer pool is a good strategy for reducing disk I/O and thereby increasing throughput. Persistit is designed to manage extremely large buffer pools very efficiently, so if memory is available, it is generally a good strategy to maximum buffer pool size.

== Transactions

Persistit supports transactions with full isolation and optimistic concurrency control. An application may begin, commit or roll back the current transaction scope explicitly, executing multiple database operations in an atomic, consistent, isolated and (optionally) durable (ACID) manner. If the application does not explicitly define the scope of a transaction, each database operation implicitly runs within the scope of a separate transaction. Each Persistit transaction may optionally be committed to either memory or disk. Transactions committed to memory are much faster, but are not immediately durable. (See Transactions.)

=== Optimistic transaction Scheduling

To achieve high performance and scalability, Persistit supports optimistic transaction scheduling. Multiple threads, each concurrently running a transaction, are permitted to continue without blocking until a potentially inconsistent state is recognized. At this point the suspected transaction is implicitly rolled back.

Optimistic scheduling works because transactions usually do not collide – especially when individual database operations are fast – and so in practice transactions are seldom rolled back. But because any transaction may be automatically rolled back at any point, applications must be designed carefully to avoid unintended side-effects. For example, no transaction should perform non-repeatable or externally visible operations within the scope of a transaction.

=== Using Transactions

The following code fragment performs two store operations within the scope of a transaction:

[source,java]
----
//
// Get the transaction context for the current thread.
//
Transaction txn = myExchange.getTransaction();
int remainingRetries = RETRY_COUNT;
Boolean done = false;
while (!done)
{
 txn.begin();
 try
 {
     myExchange.getValue().put("First value");
     myExchange.clear().append(1).store();
     myExchange.getValue().put("Second value");
     myExchange.clear().append(2).store();
     // Required to commit the transaction
     txn.commit();
     done = true;
 }
 catch (RollbackException re)
 {
     // any special rollback handling
     // allow loop to repeat until commit succeeds or retries
     // too many times.
     If (--remainingRetries < 0)
     {
         throw new TransactionFailedException();
     }
 }
 catch (PersistitException pe)
 {
     // handle other Persistit exception
 }
 finally
 {
     // Required to end the scope of a transaction.
     txn.end();
 }
}
----

This example catches +com.persistit.exception.RollbackException+, which can be thrown by any Persistit operation within the scope of a transaction, including commit. Any code explicitly running within the scope of a transaction should be designed to handle rollbacks.

This example also uses a finally block to ensure every call to +begin()+ has a matching call to +end()+.  This code pattern is mandatory: it is critical to correct transaction nesting behavior.

One convenient way to do this is to encapsulate the logic of a transaction in an implementation of +com.persisitit.TransactionRunnable+ interface. The run method of +com.persistit.Transaction+ automatically provides logic to begin the transaction, execute the TransactionRunnable and commit the transaction, repeating the process until no rollback is thrown or a maximum retry count is reached. For example, the code fragment shown above can be rewritten as:

[source,java]
----
//
// Get the transaction context for the current thread.
//
Transaction txn = myExchange.getTransaction();
//
// Perform the transaction with the following parameters:
// - try to commit it up to 10 times
// - delay 2 milliseconds before each retry
// - commit to memory
//
txn.run(new TransactionRunnable()
{
 public void run()
 throws PersistitException
 {
     myExchange.getValue().put("First value");
     myExchange.clear().append(1).store();
     myExchange.getValue().put("Second value");
     myExchange.clear().append(2).store();
 }
}, 10, 2, false);
}
----

Database operations running outside the scope of an explicitly defined transaction, (i.e., between begin and commit) are never subject to rollback and therefore do not require retry logic. However, such operations are also not guaranteed to be durable after recovery.

Note that com.persistit.exception.RollbackException is an unchecked Exception.

=== Disk vs. Memory Commits

Persistit transactions may be committed either to disk or to memory. Committing  to disk causes the commit operation to synchronously write the transaction to  the journal and limits the rate of transaction commits to the physical disk’s  random I/O rate. (Allocating the journal to an SSD volume can dramatically  improve throughput.)

Committing to memory is much faster (by several orders of magnitude) because no  synchronous disk I/O operation is required. Instead, Persistit flushes all memory-committed  transactions to disk within a fraction of a second after they committed.   Because one disk write operation may flush many transactions, this results in  much greater throughput. However, a memory-committed transaction is not durable in the event of a power failure or system interruption. In many applications  this may be a legitimate and useful compromise. Should a system fail, the recovered database will be consistent with some set of committed transactions, but will simply not include memory-committed transactions that were completed in the last few  milliseconds before failure.

Whether committed to disk or memory, whether implicit or explicit, if any transaction T is present in the recovered state of a database after an abnormal termination, Persistit guarantees that all other transactions that T depended on are also present. If transaction T2 has read a data value that was written by transaction T1, and if T2 is visible in the durable state of the database, then so is T1.

=== Nested Transactions

A nested transaction occurs when code that is already executing within the scope of a transaction executes the begin method to start a new transaction scope. This might happen, for example, if an application’s transaction logic calls a method in an external library that also uses transactions. In this case, the commit processing of the inner transaction scope is deferred until the outermost transaction commits. At that point, all the updates performed within the scope of the outer transaction are committed to the database unless an inconsistency has occurred because of updates committed by other threads. Similarly, a rollback initiated by the inner transaction causes the outermost transaction to roll back.

See the +com.persistit.Transaction+ API documentation for further details.

== Integrity and Recovery

Persistit is designed, implemented and tested to ensure that in the event the application stops abruptly without cleanly closing the database, the database remains structurally intact and in an internally consistent state after restart.

To do this, Persistit writes modified pages to the journal before writing them to the actual Volume structures. Upon restart after an abrupt termination, Persistit examines the journal, finds a valid checkpoint and restores B-tree contents accordingly, and then applies any transactions that committed after the checkpoint. This process is called _recovery_.

The journal consists of sequentially numbered files containing a variety of different record types. The journal is append-only, which allows updates to be streamed to disk very efficiently. Periodically a background Copier thread copies modified pages from the journal to their home Volumes, allowing Persistit to delete obsolete journal files. This process is efficient because often multiple versions of a page will be written to subsequent journal files; the Copier need only copy the most recent version.

Recovery depends on the availability of the volume and journal files as they existed prior to abrupt termination. If either of these is modified or destroyed outside of Persistit, successful recovery is unlikely.

=== Checkpoints

Persistit maintains a universal counter called the timestamp counter. Every  update operation assigns a new, larger timestamp, and every record in the journal includes the timestamp assigned to the operation writing the record.

A checkpoint is simply a timestamp for which a valid recovery is possible.   Periodically Persistit chooses a timestamp to be a new checkpoint, ensures that all pages updated before the checkpoint have been written to the journal, and then writes a checkpoint record to the journal.

During recovery Persistit recovers only those page images that were  writtenprior to the last valid checkpoint record. The results is that all B-Trees are internally consistent and contain all the updates that were applied before the checkpoint timestamp.

During recovery Persistit also locates all transaction records for transactions that committed after the checkpoint timestamp.  These transactions are reapplied to the B-Trees, with the result that
. The B-Tree index and data structures are intact. All store, fetch, remove and traverse operations will complete without throwing CorruptVolumeExceptions. Persistit provides the utility class com.persistit.IntegrityCheck to verify the integrity of a Volume.
. All committed transactions are present in the recovered database.  (See <<TRANSACTONS,Transactions>> for durability of disk- vs. memory-committed  transactions.)
. When update operations are applied outside of transactions, Although the precise state of the database is not defined, the resulting state is identical to some consistent, reasonably recent state prior to the termination. (Reasonably recent means within about a minute of the abrupt termination.)

=== The +flush()+ and +sync()+ Operations

An application may require certainty at various points that all pending updates have been fully written to disk. The com.persistit.Persistit class provides two methods to ensure that updates have been written:

* _flush_ causes Persistit to write all pending updates to the journal. Upon successful completion of flush any pages that needed writing prior to the call to flush are guaranteed to have been written to their respective volume files.
*  _sync_ forces the underlying operating system to write pending updates from the operating system’s write-behind cache to the actual disk. (This operation relies on the underlying java.io.FileDescriptor.sync method.)

=== Disk I/O Retries

Persistit is designed to retry any disk read or write operation that fails due to an IOException. Often the cause of an I/O failure is transient, and will resolve in time. For example, some backup programs lock files while backing them up, resulting in read and write failures in Persistit. Persistit handles read and write failures somewhat differently:

Read operations are always performed by the client thread – that is, the thread actually fetching data from an Exchange. You can specify via the system configuration whether a failure while trying to read data from a Persistit volume file should result in an immediate com.persistit.PersistitIOException by setting the readretry configuration  property to false.  Otherwise, Persistit periodically retries the read operation, ultimately throwing a com.persistit.TimeoutException if the read operation does not succeed within the timeout interval.  You can specify a default timeout interval for all operations by setting the timeout configuration property.

Write operations are usually performed by a background thread.  In the event a write operation fails, the background thread will periodically retry the operation at short intervals until it either succeeds or Persistit is shut down.

[[CONFIGURATION]]
== Configuration

To initialize Persistit the embedding application invokes one of the initialize methods of +com.persistit.Persistit+, passing either a +java.util.Properties+ object or the name of a properties file from which the Properties object derives its content. The following properties are defined for Persistit. Other properties may also reside in the Properties object or its backing file; Persistit simply ignores any property not listed here.

[horizontal]
+Buffer.count._SSSS_+:: where SSSS is 1024, 2048, 4096, 8192, or 16384. This property specifies the number of buffers of the corresponding size that Persistit will allocate for its buffer pool. For example, +buffer.count.8192=100+ allocates 100 8Kb buffers. The value must be an integer greater than 7. The maximum count is limited by available memory. Each buffer consumes SSSS bytes plus approximately 15% overhead.
+Volume._N_+:: where _N_ is an ordinal number 1, 2, etc. Specifies a Volume that Persistit is to manage. The value of this property is a specification string defined below. The ordinal number has no significance other than to provide a unique property name for each volume.
+sysvolume+:: Identifies the system volume. The system volume holds class meta data for serialized objects.
+txnvolume+:: Identifies the transaction log volume.  Uncommitted transactions are written first to this volume before being committed.
+journalpath+:: Path specification for the journal files. Each journal file name is constructed from this path plus a numeric suffix. These files are written to frequently and for maximum overall performance should be located on the fastest available physical disk drive. These files must also be available after a system failure for recovery.
+syncio+:: True or false. If true then every time Persistit performs a file write operation, it subsequently also invokes the underlying operating system’s mechanism for flush all pending I/O to physical disk storage. Otherwise, the operating system may hold pending updates in its own write-behind cache. The default value is true.
+verbose+:: True or false. If true, Persistit emits additional diagnostic log messages during its initialization. The default value is false.
+rmiport+:: Specifies a port number on which Persistit will create a temporary Remote Method Invocation registry.  If this property is specified, Persistit creates a registry and register a com.persistit.Management server on it. This allows remote access to management facilities within Persistit and permits the Swing-based administrative utility to attach to and manage a Persistit instance running on a headless server. The rmihost and rmiport properties are mutually exclusive.
+rmihost+:: Specifies the URL of an Remote Method Invocation registry.  If present, Persistit registers its a server for its com.persistit.Management interface at the specified external registry. The +rmihost+ and +rmiport+ properties are mutually exclusive.
+readretry+:: True or false. If true, Persistit retries file read operations that fail due to IOExceptions.  Retries are performed periodically until the requested read operation either succeeds or the Timeout interval is exceeded. If false, Persistit immediately throws any IOException on a read operation back to the application, wrapped in a com.persistit.PersistitIOException. The default value is true.
+timeout+:: The default timeout. Note that the timeout for a particular com.persistit.Exchange can be individually modified.  The specified time, in milliseconds, is the maximum time any Persistit operation will wait for completion of disk I/O before.  If the I/O operation cannot be completed within that interval, Persistit throws a com.persistit.TimeoutException. The default value is 60000, or one minute.
+serialOverride+, +constructorOverride+:: Control aspects of object serialization. See Persistit 1.1 Object Serialization.
+showgui+:: True of False.  If true, Persistit attempts to create and display an instance of the AdminUI utility panel on the local machine.

For all integer-valued properties, the suffix “K” may be used to represent kilo, “M” for mega, “G” for giga and “T” for tera. For example,
“2M” represents the value 2,097,152.

=== Volume Specification

Each volume specification in the configuration has the following form:

[[HORIZONTAL]]
+volume._N_ = _path_[,_attrname_[:_attrvalue_]]...+:: where _N_ is an arbitrary integer, _path_ is the path specification of the volume file, and _attrnames_ include:
- +create+: Persistit attempts to open an existing volume file with the specified _path_, or create a new one if the file does not exist.
- +createOnly+: Persistit throw a VolumeAlreadyExistsException if the file specified by path already exists. Otherwise it creates a new file with the specified path.
- +readOnly+: Opens a volume in read-only mode. An attempt to modify the volume results in a ReadOnlyVolumeException.
- +initialPages+ or +initialSize+: Specifies the initial size of the newly created volume file, either as the count of pages or as the size in bytes.
- +extensionPages+ or +extensionSize+: Specifies the extension size of the newly created volume, either as the count of pages or as the size in bytes. This is the size by which the volume file will expand when the volume needs to be enlarged.
- +maximumPages+ or +maximumSize+: An upper limit on the number of pages this Volume may hold, either as the count of pages or as the size in bytes. An attempt to further enlarge the Volume will generate a VolumeFullException.
- +alias+: The name of this Volume used in constructing +Exchange+ instances.  If unspecified, the name is the file name given in the _path_, not including its dotted suffix.

=== System Volume

One volume in a Persistit configuration must be designated as the system volume. It contains class meta data for objects stored serialized in Persistit Values. When a configuration specifies only one volume, that volume implicitly becomes the system volume. However, when a configuration specifies multiple volumes, you must specify which volume should be designated as the system volume. There are two ways to do this. By default, Persistit looks for a unique volume whose name contains the string “_system”. You can simply create a volume whose path name contains “_system”.

Alternatively, you can specify a different volume name with the +sysvolume+ property. The value specified for this name may either be the alias of a volume chosen to be the system volume, or a unique partial match on the path name of this volume.  The configuration example shown below illustrates a configuration using an alias.

=== Transaction Volume

Analogous to the System Volume, Persistit uses a designated volume called the Transaction Volume to store a log of transaction data prior to transaction commit. A configuration with only one volume implicitly uses that one volume for this purpose.  However, in a multi-volume configuration you must specify which volume is to serve in this role.  By default Persistit looks for a volume whose path name contains “_txn” or whose alias exactly matches “_txn”, or a volume named by the +txnvolume+ property.

=== A Configuration Example

Following is an example of a Persistit configuration properties file:

----
datapath = /var/opt/persistit/data

logpath = /var/log/persistit

verbose = true

logfile = ${logpath}/${timestamp}.log

buffer.count.8192 = 5000

volume.1 = ${datapath}/demo_data.v01, create, pageSize:8192, \
    initialSize:1M, extensionSize:1M, maximumSize:10G, alias:data

volume.2 = ${datapath}/demo_txn.v01, create, pageSize:8192, \
    initialSize:100K, extensionSize:100K, maximumSize:1G

sysvolume = persistit

journalpath = /data/persistit_journal
----

With this configuration there will be 5,000 8Kb buffers in the buffer pool (consuming heap space of approximately 46MB including overhead). Persistit will open or create volume files named +/data/demo_data.v01+ and +/data/demo_txn.v01+ and a journal file named +/data/persistit_journal.0000000000000001+.

The +demo_data.v01+ volume has the alias +data+. This means that application code uses the name "data" to refer to that volume. The +sysvolume+ property specifies that this volume is also designated to hold class meta data for serialized objects.

The +demo_txn.v01+ volume serves as the transaction volume for this configuration. Persistit recognizes it as such because its path name contains the string “_txn”. The configuration could instead specify a different name using the +txnvolume+ system property.

=== Property Value Substitution

This example also illustrates how property value substitution can be used within a Persistit configuration.  The value of +datapath+ value replaces _${datapath}_ in the volume specification. The property name datapath is arbitrary; you may use any valid property name as a substitution variable. Similarly, the value of +logpath+ replaces _${logpath}_. The pseudo-property _${timestamp}_ expands to a timestamp in the form yyyyMMddHHmm. This providess a unique time-based log file name.

You may also specify any configuration property as a Java system property with the prefix +com.persisit.+ System properties override values specified in the configuration file.  For example, you can override the value of +buffer.count.8192+ specifying +-Dcom.persistit.buffer.count.8192=10K+ as a command-line switch when starting Java. This is also true for substitution property values. For example, +-Dcom.persistit.logpath=/tmp/+ will place the log files in the +/tmp+ directory rather than +/var/log/persistit+ as specified by the configuration file.

== Logging API

Persistit is writes various diagnostic and informational messages to a log. By default, the log is written as text to the file +persistit.log+ in the current working directory. However, a container application will usually have a logging architecture already in place, and Persistit provides a simple way to redirect its log output to the container application’s log. Adapters for Log4J and the Java Logging API are included; other logging systems are easy to adapt.

See the API documentation for com.persistit.logging.AbstractPersistitLogger for details.


