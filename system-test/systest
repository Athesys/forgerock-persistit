#!/bin/bash
set +e
#
# Help function to describe usage
#

TEAMCITY=${TEAMCITY:-0}
PUBLISH=${PUBLISH:-0}

declare -a properties

PERSISTIT_JAR="../target/akiban-persistit-2.1-SNAPSHOT-jar-with-dependencies-and-tests.jar"
CSERVER_JAR="${cserver_base}/usr/local/chunkserver/akiban-cserver-0.0.2-SNAPSHOT-jar-with-dependencies.jar"
MANAGER_JAR="${cserver_base}/usr/local/chunkserver/akiban-manager-service-core-jar-with-dependencies.jar"
TEST_JAR="target/akiban-system-tests-0.0.2-SNAPSHOT-jar-with-dependencies.jar"

trap 'onErr'  ERR  
trap 'onExit' EXIT
start_now=`date +%s`

function onExit
{
	time_now=$(date  --date "now - ${start_now} sec" "+%s")
	info "TOTAL TIME:  ${time_now} seconds"
}

function onErr
{
	Err=${?}
	#show-props
	#status	
	
	# when anything breaks, 
	# i want to stop my services. so that subsequent bind to ports work
	#stop
	if [ ${TEAMCITY} -gt 1 ]; then
		kill-all	
	fi
	
	#clean
	error "*******ERROR:${Err}" 
}


# run a testng test
# arg testname e.g com.akiban.test.foo
#
function persistit-test
{	
#	[[ $- =  *e* ]]; local olde=$?	
	set -e
# 	remove for verbose logging in function
#	set -x
	#
	# time we want to run the test before signal is sent
	# FIXME - not sure where the shift from 2 -> 1 gets done in the normal script
	#
	local time="${1}"
	# optional jvmargs
	local jvmargs="${2}"
	if [ -z ${time} ]; then
		error "time to wait is required"
	fi
	
	local classpath="${PERSISTIT_JAR}"
	local mainClass="com.persistit.test.TestRunner"
	local args="script=recovery_1.plan datapath=/tmp/persistit_test_data logpath=/tmp/persistit_test_data"

	java -ea ${jvmargs} -cp ${classpath} ${mainClass} ${args} 1>/tmp/persistit_test_data/recovery.log & local PID=$!
	#let it run a bit
	info "process PID=${PID} started, sleeping for ${time} seconds" && sleep ${time} 

	# you can send any signal here
	kill -9 ${PID}	|| warn "process PID=${PID} does not exist, proceeding with verification anyways"

	# wait for child pid to process signal and then die
	wait ${PID}     || info "nothing to wait for, process completed handling signal" 

	#process verification here 
	local arg1="script=recovery_2.plan datapath=/tmp/persistit_test_data"
	java -ea $jvmargs -cp ${classpath} ${mainClass} ${arg1}
	local ret=$?
	if [ ${ret} -eq 0 ]; then
		info "success"
	else
		error "failed with error code ${ret}"
	fi


	# revert to old set -e settings
	if [ ${olde} -eq 0 ]; then set -e; else set +e; fi
}


#########################################
# Utility methods
#########################################


function warn
{
	local message=${1}
	echo "`date` WARN: ${message}" 
}

function error
{
	local message=${1}
	echo "`date` ERROR: ${message}" 
	exit 1
}


#
# tail logs
#
#
function tail-logs
{
	info "tailing ${log_error} ${log4j_appender_rollingfile_File}"
	tail  -f ${log_error} ${log4j_appender_rollingfile_File}
}

function info
{
	local message=${1}
	echo "$(date "+%Y/%m/%d %H:%M:%S") INFO: ${message}" 
}


#
# timestamp functions
# print time it took to run a function when function returns
#
function ts 
{
	for  function in "$@"
	do
		starttime=`date +%s`

		if [ ${TEAMCITY} -gt 0 ]; then
			echo "##teamcity[testStarted name='${function}']"
		fi

		${function} 
		#${function} 1>results/${function}.${starttime}.log 
		ret=$?
		timetaken=$(date  --date "now - ${starttime} sec" "+%s")
		
		if [ ${TEAMCITY} -gt 0 ]; then
			echo "##teamcity[testFinished name='${function}' duration='${timetaken}']"
		fi
		info "** SUCCESS FUNCTION [${function}] returned (${ret}) in ${timetaken} seconds"
	done
}



#residual args are functions
ts "$@"
