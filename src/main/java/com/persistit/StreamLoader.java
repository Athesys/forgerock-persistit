/*
 * Copyright (c) 2004 Persistit Corporation. All Rights Reserved.
 *
 * The Java source code is the confidential and proprietary information
 * of Persistit Corporation ("Confidential Information"). You shall
 * not disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Persistit Corporation.
 *
 * PERSISTIT CORPORATION MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE
 * SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
 * A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. PERSISTIT CORPORATION SHALL
 * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
 * MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 * 
 * Created on Mar 3, 2005
 */
package com.persistit;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

import com.persistit.exception.CorruptImportStreamException;
import com.persistit.exception.PersistitException;

/**
 * Loads Persistit records from a file or other stream in a format generated by
 * a {@link StreamSaver}. 
 * @version 1.0
 */
public class StreamLoader
extends Task
{
    /**
     * Default for BufferedInputStream buffer size.
     */
    public final static int DEFAULT_BUFFER_SIZE = 65536;
    
    protected DataInputStream _dis;
    
    protected Key _key = new Key((Persistit)null);
    protected Value _value = new Value((Persistit)null);
    protected Volume _lastVolume;
    protected Tree _lastTree;
    protected int _dataRecordCount = 0;
    protected int _otherRecordCount = 0;
    protected boolean _stop;
    protected Exception _lastException;
    protected boolean _verbose;
    
    protected String _taskSelectedVolumeName;
    protected String _taskSelectedTreeName;
    protected String _taskKeyFilterString;
    protected boolean _taskCreateMissingVolumes;
    protected boolean _taskCreateMissingTrees;
    protected ImportHandler _handler;

    /**
     * Package-private constructor for use in a {@link Task}.
     *
     */
    StreamLoader()
    {
    }
    
    public StreamLoader(final Persistit persistit, final DataInputStream dis)
    {
    	super(persistit);
        _dis = dis;
    }
    
    public StreamLoader(final Persistit persistit, BufferedInputStream bos)
    {
    	super(persistit);
        _dis = new DataInputStream(bos);
    }
    
    public StreamLoader(final Persistit persistit, InputStream os)
    {
    	super(persistit);
        _dis = new DataInputStream(
            new BufferedInputStream(os, DEFAULT_BUFFER_SIZE));
    }
    
    public StreamLoader(final Persistit persistit, File file)
    throws FileNotFoundException
    {
        this(persistit, new FileInputStream(file));
    }
    
    public StreamLoader(final Persistit persistit, String pathName)
    throws FileNotFoundException
    {
        this(persistit, new FileInputStream(pathName));
    }
    
    public boolean isVerbose()
    {
        return _verbose;
    }
    
    public void setVerbose(boolean b)
    {
        _verbose = b;
    }
    
    public void close()
    throws IOException
    {
        _dis.close();
    }

    public void load()
    throws IOException, PersistitException
    {
        load(
            null,
            null,
            null,
            true,
            true);
    }
    
    public void load(String selectedVolumeName)
    throws IOException, PersistitException
    {
        load(
            selectedVolumeName,
            null,
            null,
            true,
            true);
    }
    
    public void load(String selectedVolumeName, String selectedTreeName)
    throws IOException, PersistitException
    {
        load(
            selectedVolumeName,
            selectedTreeName,
            null,
            true,
            true);
    }
    
    public void load(
        String selectedVolumeName, 
        String selectedTreeName, 
        String keyFilterString)
    throws IOException, PersistitException
    {
        load(
            selectedVolumeName,
            selectedTreeName,
            keyFilterString,
            true,
            true);
    }
    
    public void load(
        String selectedVolumeName, 
        String selectedTreeName, 
        String keyFilterString,
        boolean createMissingVolumes,
        boolean createMissingTrees)
    throws IOException, PersistitException
    {
        KeyFilter filter = null;
        
        if (keyFilterString != null && 
            keyFilterString.length() > 0)
        {
            filter = new KeyFilter(keyFilterString);
        }
        _handler =
            new ImportHandler(
            	_persistit,
                selectedVolumeName, 
                selectedTreeName, 
                createMissingVolumes, 
                createMissingTrees, 
                filter);
        load(_handler);
        close();
    }
    
    public void load(ImportHandler handler)
    throws IOException, PersistitException
    {
        while (readAndDispatchOneRecord(handler));
    }

    private boolean readAndDispatchOneRecord(ImportHandler handler)
    throws PersistitException, IOException
    {
        int b1 = _dis.read();
        if (b1 == -1) return false;
        
        int b2 = _dis.read();
        int recordType = ((b1 & 0xFF) << 8) + (b2 & 0xFF);
        
        switch (recordType)
        {
            case StreamSaver.RECORD_TYPE_FILL:
            {
                handler.handleFillRecord();
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_DATA:
            {
                int keySize = _dis.readShort();
                int elisionCount = _dis.readShort();
                int valueSize = _dis.readInt();
                _value.ensureFit(valueSize);
                _dis.read(
                    _key.getEncodedBytes(), 
                    elisionCount, 
                    keySize - elisionCount);
                _key.setEncodedSize(keySize);
                _dis.read(
                    _value.getEncodedBytes(),
                    0,
                    valueSize);
                _value.setEncodedSize(valueSize);
                handler.handleDataRecord(_key, _value);
                _dataRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_KEY_FILTER:
            {
                String filterString = _dis.readUTF();
                handler.handleKeyFilterRecord(filterString);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_VOLUME_ID:
            {
                long id = _dis.readLong();
                long initialPages = _dis.readLong();
                long extensionPages = _dis.readLong();
                long maximumPages = _dis.readLong();
                int bufferSize = _dis.readInt();
                String volumeName = _dis.readUTF();
                handler.handleVolumeIdRecord(
                    id,
                    initialPages,
                    extensionPages,
                    maximumPages,
                    bufferSize,
                    volumeName);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_TREE_ID:
            {
                int treeIndex = _dis.readInt();
                String treeName = _dis.readUTF();
                handler.handleTreeIdRecord(treeIndex, treeName);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_HOSTNAME:
            {
                String hostName = _dis.readUTF();
                handler.handleHostNameRecord(hostName);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_USER:
            {
                String hostName = _dis.readUTF();
                handler.handleUserRecord(hostName);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_COMMENT:
            {
                String comment = _dis.readUTF();
                handler.handleCommentRecord(comment);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_COUNT:
            {
                long dataRecordCount = _dis.readLong();
                long otherRecordCount = _dis.readLong();
                handler.handleCountRecord(dataRecordCount, otherRecordCount);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_START:
            {
                handler.handleStartRecord();
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_END:
            {
                handler.handleEndRecord();
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_TIMESTAMP:
            {
                long timeStamp = _dis.readLong();
                handler.handleTimeStampRecord(timeStamp);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_EXCEPTION:
            {
                String exceptionString = _dis.readUTF();
                handler.handleExceptionRecord(exceptionString);
                _otherRecordCount++;
                break;
            }
            case StreamSaver.RECORD_TYPE_COMPLETION:
            {
                handler.handleCompletionRecord();
                _otherRecordCount++;
                return false;
            }
            default:
            {
                throw new CorruptImportStreamException(
                    "Invalid record type " + recordType + " (" + 
                    Util.bytesToHex(new byte[] {
                        (byte)(recordType >>> 8),
                        (byte) recordType}) +
                    " after reading " + _dataRecordCount + " data records" +
                    " and " + _otherRecordCount + " other records");
            }
        }
        if ((_dataRecordCount + _otherRecordCount) % 100 == 0) poll();
        return true;
    }

    public static class ImportHandler
    {
    	protected Persistit _persistit;
        protected String _selectedVolumeName;
        protected String _selectedTreeName;
        protected KeyFilter _keyFilter;
        protected Exchange _exchange;
        protected Volume _volume;
        protected Tree _tree;
        protected boolean _createMissingVolumes;
        protected boolean _createMissingTrees;
        
        public ImportHandler(Persistit persistit)
        {
            this(persistit, null, null, true, true, null);
        }
        
        public ImportHandler(
        	Persistit persistit,
            String selectedVolumeName, 
            String selectedTreeName, 
            boolean createMissingVolumes, 
            boolean createMissingTrees,
            KeyFilter keyFilter)
        {
        	_persistit = persistit;
            _selectedTreeName = selectedTreeName;
            _selectedVolumeName = selectedVolumeName;
            _createMissingTrees = createMissingTrees;
            _createMissingVolumes = createMissingVolumes;
            _keyFilter = keyFilter;
        }
        
        public void handleFillRecord()
        throws PersistitException
        {
        }
        
        public void handleDataRecord(Key key, Value value)
        throws PersistitException
        {
            if (_keyFilter == null || _keyFilter.selected(key))
            {
                if (_volume == null || _tree == null) return;
                if (_exchange == null)
                {
                    _exchange = _persistit.getExchange(_volume, _tree.getName(), false);
                }
                key.copyTo(_exchange.getKey());
                // Using this package-private method allows us to avoid copying
                // the value field.
                _exchange.store(_exchange.getKey(), value);
            }
        }
        
        public void handleKeyFilterRecord(String keyFilterString)
        throws PersistitException
        {
        }
        
        public void handleVolumeIdRecord(
            long volumeId,
            long initialPages,
            long extensionPages,
            long maximumPages,
            int bufferSize,
            String volumeName)
        throws PersistitException
        {
            Exchange oldExchange = _exchange;
            _exchange = null;
            _volume = null;
            _tree = null;
            
            _volume = _persistit.getVolume(volumeId);
            
            if (_selectedVolumeName != null)
            {
                if (
                    _volume != null &&
                    _volume.getPathName().indexOf(_selectedVolumeName) < 0)
                {
                    _volume = null;
                }
                if (_volume == null &&
                    volumeName.indexOf(_selectedVolumeName) < 0)
                {
                    return;
                }
            }
            
            if (_volume == null)
            {
                _volume = _persistit.getVolume(volumeName);
            }
            if (_volume == null && _createMissingVolumes)
            {
                _volume = Volume.create(
                    _persistit,
                    volumeName, 
                    volumeId, 
                    bufferSize, 
                    initialPages,
                    extensionPages,
                    maximumPages,
                    false,
                    false);
            }
            if (oldExchange != null && oldExchange.getVolume() == _volume)
            {
                _exchange = oldExchange;
            }
        }
        
        public void handleTreeIdRecord(int treeIndex, String treeName)
        throws PersistitException
        {
            Exchange oldExchange = _exchange;
            _exchange = null;
            _tree = null;
            if (_selectedTreeName != null &&
                treeName.indexOf(_selectedTreeName) == -1)
            {
                return;
            }
            
            if (_volume != null)
            {
                _tree = _volume.getTree(
                    treeName, 
                    _createMissingVolumes | _createMissingTrees);
            }
            if (oldExchange != null && oldExchange.getTree() == _tree)
            {
                _exchange = oldExchange;
            }
        }
        
        public void handleTimeStampRecord(long timeStamp)
        throws PersistitException
        {
        }

        public void handleHostNameRecord(String hostName)
        throws PersistitException
        {
        }

        public void handleUserRecord(String userName)
        throws PersistitException
        {
        }
        
        public void handleCommentRecord(String comment)
        throws PersistitException
        {
        }
        
        public void handleCountRecord(long keyValueRecords, long otherRecords)
        throws PersistitException
        {
        }
        
        public void handleStartRecord()
        throws PersistitException
        {
        }

        public void handleEndRecord()
        throws PersistitException
        {
        }
        
        public void handleExceptionRecord(String exceptionString)
        throws PersistitException
        {
        }
        
        public void handleCompletionRecord()
        throws PersistitException
        {
        }

    }
    
    protected void setupTask(String[] args)
    throws Exception
    {
        _dis = new DataInputStream(
            new BufferedInputStream(
                new FileInputStream(args[0]), DEFAULT_BUFFER_SIZE));
        _taskSelectedVolumeName = args.length > 1 ? args[1] : null;
        _taskSelectedTreeName = args.length > 2 ? args[2] : null;
        _taskKeyFilterString = args.length > 3 ? args[3] : null;
        _taskCreateMissingVolumes = args.length > 4 && "true".equals(args[4]);
        _taskCreateMissingTrees = args.length > 5 && "true".equals(args[5]);
    }
    
    public void runTask()
    throws Exception
    {
        load(
            _taskSelectedVolumeName,
            _taskSelectedTreeName,
            _taskKeyFilterString,
            _taskCreateMissingVolumes,
            _taskCreateMissingTrees);
    }
    
    public String getStatus()
    {
        if (_handler == null || _handler._tree == null)
        {
            return null;
        }
        Tree tree = _handler._tree;
        return 
            tree.getName() + 
            " in " + tree.getVolume().getPathName() + 
            " (" + _dataRecordCount + ")";
    }
}
